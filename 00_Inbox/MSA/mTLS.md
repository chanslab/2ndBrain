#상호인증 #보안 #HTTPS #TLS #MSA #service_mesh

**mTLS(Mutual TLS, 상호 인증 TLS)**는 클라이언트와 서버가 **서로의 신원을 동시에 확인**하는 보안 방식입니다.

일반적인 TLS(HTTPS)에서는 클라이언트가 서버의 인증서를 확인하여 "내가 접속한 사이트가 가짜가 아니구나"라고 믿는 방식이라면, mTLS는 서버 또한 클라이언트에게 인증서를 요구하여 "허가된 사용자가 맞구나"라고 서로 확인하는 과정을 거칩니다.

![[Pasted image 20260108214936.png]]

---

## 1. 일반 TLS vs mTLS 차이점

|**구분**|**일반 TLS (단방향)**|**mTLS (양방향)**|
|---|---|---|
|**인증 대상**|서버만 인증|서버와 클라이언트 모두 인증|
|**주요 사용처**|일반 웹사이트 (브라우저 접속)|**MSA 내부 통신**, API 통신, B2B 연결|
|**보안 수준**|중간 (서버 신뢰 중심)|**높음 (Zero Trust 모델)**|

---

## 2. mTLS가 작동하는 방식 (Handshake)

mTLS 과정은 다음과 같은 순서로 진행됩니다.

1. **서버 인사**: 클라이언트가 접속하면 서버가 자신의 **공개 키**와 **인증서**를 보냅니다.
    
2. **서버 검증**: 클라이언트는 서버의 인증서가 유효한지 확인합니다.
    
3. **클라이언트 인증 요청**: (mTLS의 핵심) 서버가 클라이언트에게 **"너의 인증서도 보내줘"**라고 요청합니다.
    
4. **클라이언트 인사**: 클라이언트가 자신의 인증서를 서버에 보냅니다.
    
5. **클라이언트 검증**: 서버는 클라이언트의 인증서를 확인하여 신원을 보장받습니다.
    
6. **암호화 통신 시작**: 양쪽 모두 확인이 끝나면 세션 키를 생성하여 데이터를 암호화합니다.
    

---

## 3. MSA에서 mTLS를 사용하는 이유

 **MSA(Microservices Architecture)** 환경에서 mTLS는 필수적인 보안 패턴 중 하나입니다.

- **Zero Trust(제로 트러스트)**: "내부 네트워크에 있는 서비스니까 안전하겠지"라는 가정을 버리고, 모든 서비스 간 호출 시마다 신원을 확인합니다.
    
- **서비스 간 권한 제어**: 인증서 정보를 바탕으로 특정 서비스가 다른 서비스에 접근할 권한이 있는지 세밀하게 통제할 수 있습니다.
    
- **데이터 암호화**: 서비스 간에 주고받는 모든 데이터가 암호화되어, 혹시라도 내부 망이 침투당했을 때 데이터 유출을 막습니다.
    

> **참고**: MSA 환경에서는 수많은 서비스의 인증서를 수동으로 관리하기 어렵기 때문에, 보통 **Service Mesh(예: Istio, Linkerd)** 솔루션을 사용하여 mTLS를 자동으로 적용하고 관리합니다.

---

## 4. mTLS의 단점

- **관리 복잡성**: 모든 클라이언트(서비스)에 인증서를 배포하고, 만료되기 전에 갱신해야 하는 운영 부담이 큽니다.
    
- **성능 부하**: 양방향으로 인증서를 검증하는 과정에서 CPU 자원을 더 사용하며, 초기 연결 시간이 약간 더 길어질 수 있습니다.
